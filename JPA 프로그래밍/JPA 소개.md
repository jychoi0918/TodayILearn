# JPA 기본편

### 목표

- 객체와 테이블 설계 매핑
    - 객체와 테이블을 제대로 설계, 매핑
    - 기본 키 외래 키 매핑
    - 1:N, N:1, 1:1, N:M 매핑
    - 실무 노하우+ 성능까지 고려 = > 복잡한 시스템도 JPA로 설계 가능

- JPA 내부 동작 방식 이해
    - JPA의 내부 동작 방식을 이해하지 못하고 사용
    - JPA 내부 동작 방식을 그림과 코드로 자세히 설명
    - JPA가 어떤 SQL을 만들어내는지, 언제 SQL을 실행하는 지 이해

    ### SQL 중심적인 개발의 문제점

    - 무한 CRUD 반복 ⇒ SQL 의존적인 개발
    - 객체형 / 관계형의 패러다임의 불일치
        - 객체를 관계형 데이터 베이스에 저장
        - 상속/연관관계/데이터 타입/데이터 식별방법의 차이


# JPA와 모던 자바 데이터 저장 기술

지금 시대는 객체를  RDB에 저장해서 사용 (RDB = 관계형 데이터베이스)

⇒ 모든 것이 SQL 중심적 개발의 **문제점**

### RDB를 사용함으로서 문제점들

1. **무한 반복, 지루한 코드** - CRUD, 필드 추가 시 CRUD쿼리 모두 수정

⇒ SQL 의존적 개발을 피하기 어렵다

1. **패러다임의 불일치** - 객체 vs RDB  근본 규정이 다름! 하지만 현실적 대안은 RDB

⇒ 즉, 개발자는 SQL 매퍼가 된다. 

**객체와 RDB의 차이** 

 -상속, 연관관계, 데이터 타입, 데이터 식별 방법 등등

- 상속 : 자바 컬렉션에서 조회시 간단하다. 하지만, RDB에서 조회시 매핑이 필요하다.
- 연관관계 : 객체는 참조를 사용, 테이블은 외래 키를 사용 하지만 객체는 단방향 이지만, 테이블을 양방향인 차이가 있다.
- 객체 그래프 탐색 : 객체는 자유롭게 객체 그래프를 탐색할 수 있다. 하지만, RDB로 인해 처음 실행하는 SQL에 따라 탐색 범위를 결정. 이로 인한 앤티티 신뢰 문제 발생 - 코드를 다 확인을 해봐야지 확인 가능.(반환 범위를 알 수 없기 때문에)

1. **계층형 아키텍처의 진정한 의미의 계층 분할이 어렵다.**

즉 객체답게 모델링을 할수록 매핑 작업만 늘어난다.

그래서 **JPA**!!

# JPA

Java Persistence API

자바 진영의 ORM 기술 표준

- ORM? - Object-relational mapping(객체 관계 매핑)

-객체는 객체대로 설계

-관계형 데이터베이스는 관계형 데이터 베이스 대로 설계

-ORM 프레임워크가 중간에서 매핑

-대중적인 언어에는 대부분 ORM 기술이 존재

JPA는 애플리케이션과 JDBC 사이에서 동작

JVM 내의 JPA가

- Entity 분석, CRUD SQL 생성, JDBC API사용, 패러다임 불일치 해결

JPA는 인터페이스의 모음이다.

### JPA 사용이유

- SQL 중심적 개발 → 객체 중심적 개발
- 생산성 : jpa를 이용한 CRUD
- 유지보수 : jpa는 필드만 추가하면 sql을 jpa가 처리
- 패러다임 불일치 해결 - 상속, 신뢰할 수 있는 엔티티와 계층 (같은 트랜잭셕ㄴ
- 성능  (캐시와 동일성 보장, 트랜잭션을 지원하는 쓰기 지연 , 지연로딩 즉시 로딩 )

-지연로딩 - 객체가 실제 사용될 때 로딩

-즉시로딩 - JOIN SQL 로 한번에 연관된 객체까지 미리 조회

-JPA에서 옵션을 이용하여 선택할 수 있다. 

- 데이터 접근 추상화와 벤더 독립성
- 표준

ORM은 객체와 RDB 둘 사이의 균형을 잘 맞춰야 한다.