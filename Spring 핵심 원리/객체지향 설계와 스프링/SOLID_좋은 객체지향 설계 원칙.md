# SOLID_좋은 객체지향 설계 원칙

SOLID란

클린코드로 유명한 로버트 마틴이 만든 다섯가지 원칙!
***


# 단일책임 원칙 SRP

**Single Responsiblility principle**

- 한 클래스는 하나의 책임만 가져야 한다. →모호

어떤 기준을 가지고 단일책임 원칙을 따르며 설계가 잘되었다고 할 수 있을까?

### **변경!**

변경을 했을 때 파급이 적을 수록 SRP가 잘 되었다고 할 수있다.

***


# 개방-폐쇄 원칙 OCP

**Open/Closed principle**



소프트웨어 요소는 확장에는 열려있고 변경에는 닫혀있어야 한다.

코드의 변경없이 확장이 가능하다 ⇒인터페이스(**다형성**)이용!

인터페이스를 통해 새로운 클래스를 만드는 것은 기존 코드를 변경하는 것이 아님!

 

문제점

- 구현객체를 변경하려면 클라이언트 코드를 변경해야한다.

⇒OCP가 깨짐. 이것을 위해 SPRING DI/IoC 컨테이너가 생겨남!
***

# 리스코프 치환 원칙 LSP

**Liskov Substitution principle**



- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야한다.
- 즉, 다형성의 하위클래스는 인터페이스 규약을 지켜야한다!

    ⇒다형성을 지원하기 위한 원칙, 인터펫이스를 구현한 구현체는 믿고 사용하려면 이 원칙 필요

예) 엑셀은 앞으로 가야한다(인터페이스 규약) . 기능을 변경하더라도 앞으로는 가야한다.
***

# 인터페이스 분리 원칙 ISP

**Interface Segregation principle**



특정 클라이언트를 위한 인터페이스 여러개 are better than 범용 인터페이스 하나

- 자동차 interface ⇒ 운전 interface / 정비 interface로 분리
- 사용자 client ⇒ 운전자 client, 정비사 client 분리

 더 분리를 함으로 인해, 운전 interface가 변경이 되어도 정비사 client에게는 영향 X

인터페이스 명확, 대체 가능성 증가
***

# 의존관계 역전 원칙 DIP

**Dependency inverstion principle**



추상화에 의존해야지, 구현체에 의존하면안되다

= 구현클래스 의존X , 인터페이스 의존

= **역할에 의존하게 해야한다!**

역할에 의존하면 안된다.  but 위반이 될 때가 있다.


***



### 정리!!

객체 지향의 핵심은 **다형성**

but 다형성 만으로는 OCP, DIP를 지킬 수 없다.
